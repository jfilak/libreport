# -*- Autotest -*-

AT_BANNER([/proc helpers])

## -------------------- ##
## get_env_variable_ext ##
## -------------------- ##

AT_TESTFUN([get_env_variable_ext],
[[

#include "testsuite.h"

void test_delim(char delim)
{
    const char *test_data[][2] = {
            { "EMPTY", "" },
            { "SATYR", "awesome" },
            { "STUFF", "" },
            { "OPENSOURCE", "brilliant" },
            { "LIBREPORT", "great" },
            { "TRICK", "" },
            { "ABRT", "fabulous" },
            { "SENTINEL", NULL}
        };


    char fdname[] = "/tmp/libreprt-testsuite.XXXXXX";
    int fd = mkstemp(fdname);
    assert(fd >= 0);
    printf("Temporary file: %s\n", fdname);

    int fddup = dup(fd);
    assert(fddup >= 0);

    FILE *f = fdopen(fddup, "w");
    assert(f);

    for (size_t i = 0; i < ARRAY_SIZE(test_data); ++i)
    {
        if (test_data[i][1] == NULL)
            continue;

        fprintf(f, "%s=%s", test_data[i][0], test_data[i][1]);

        /* Do not add delimiter after the last entry */
        if (i < ARRAY_SIZE(test_data) - 1)
            fputc(delim, f);
    }

    fclose(f);

    for (size_t i = ARRAY_SIZE(test_data); i != 0; --i)
    {
        lseek(fd, 0, SEEK_SET);
        char *value = NULL;
        printf("Looking for '%s'\n", test_data[i-1][0]);
        TS_ASSERT_FUNCTION(get_env_variable_ext(fd, delim, test_data[i-1][0], &value));
        TS_ASSERT_STRING_EQ(value, test_data[i-1][1], "Environment value at 'i'");
        free(value);
    }

    close(fd);
}

TS_MAIN
{
    test_delim('\n');
    test_delim('\0');
}
TS_RETURN_MAIN
]])


## ---------------- ##
## get_env_variable ##
## ---------------- ##

AT_TESTFUN([get_env_variable],
[[

#include "testsuite.h"

TS_MAIN
{
    char cwd[257];
    getcwd(cwd, sizeof(cwd));

    char *value = NULL;
    TS_ASSERT_FUNCTION(get_env_variable(getpid(), "PWD", &value));
    TS_ASSERT_STRING_EQ(value, cwd, "Test environment variable - PWD");
    free(value);
}
TS_RETURN_MAIN
]])

## ----------- ##
## get_cmdline ##
## ----------- ##

AT_TESTFUN([get_cmdline], [[
#include "testsuite.h"
#include <err.h>

void test(const char *program, const char *args[], const char *expected)
{
    int inout[2];
    xpipe(inout);

    pid_t pid = fork();
    if (pid < 0) {
        err(EXIT_FAILURE, "fork");
    }

    if (pid == 0) {
        close(STDOUT_FILENO);
        xdup2(inout[1], STDOUT_FILENO);
        close(inout[0]);

        execv(program, (char **)args);
        err(EXIT_FAILURE, "exec(%s)", program);
    }

    close(inout[1]);
    int status = 0;
    if (safe_waitpid(pid, &status, 0) < 0) {
        err(EXIT_FAILURE, "waitpid");
    }

    if (WEXITSTATUS(status) != 0) {
        errx(EXIT_FAILURE, "Child not exited with 0");
    }

    const size_t buffer_size = strlen(expected) * 2;
    char cmdline[buffer_size];
    const ssize_t total = full_read(inout[0], cmdline, buffer_size);
    close(inout[0]);

    if (total < 0) {
        err(EXIT_FAILURE, "full_read");
    }

    cmdline[total] = '\0';
    TS_ASSERT_STRING_EQ(cmdline, expected, "/proc/[pid]/cmd");
}

TS_MAIN
{
    if (argc > 1) {
        char *cmdline = NULL;
        if (strcmp(argv[0], "get_cmdline") == 0) {
            cmdline = get_cmdline(getpid());
        }
        else if (strcmp(argv[0], "get_cmdline_at") == 0) {
            int pid_proc_fd = open("/proc/self", O_DIRECTORY);
            if (pid_proc_fd < 0) {
                err(EXIT_FAILURE, "open(/proc/self, O_DIRECTORY)");
            }
            cmdline = get_cmdline_at(pid_proc_fd);
            close(pid_proc_fd);
        }
        else {
            errx(EXIT_FAILURE, "Unsupported function type '%s'", argv[0]);
        }

        fprintf(stdout, "%s", cmdline);
        fflush(stdout);
        exit(EXIT_SUCCESS);
    }

    char *binary = malloc_readlink("/proc/self/exe");
    const char *args[] = { NULL, "!fo\" \"o", "@blah", "b\na'r", "g\rea\t", "regular", NULL };

#define EXPECTED " '!fo\\\" \\\"o' @blah 'b\\na\\'r' 'g\\rea\\t' regular"

    args[0] = "get_cmdline";
    test(binary, args, "get_cmdline" EXPECTED);

    args[0] = "get_cmdline_at";
    test(binary, args, "get_cmdline_at" EXPECTED);

    free(binary);
}
TS_RETURN_MAIN
]])
